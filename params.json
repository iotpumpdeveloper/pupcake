{"tagline":"Pupcake, a PHP 5.3+ application framework","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"Pupcake --- a micro framework for PHP 5.3+\r\n=======================================\r\n\r\n##About Pupcake Framework\r\n+ Pupcake is a minimal but extensible microframework for PHP 5.3+\r\n+ Pupcake can be run in traditional web server such as Apache and can also run as a standalone async server using the AsyncServer plugin together with php-uv and php-httpparser\r\n  (The standalone async server is at its very early stage and is under active development)\r\n+ For more detail usages, please see https://github.com/superjimpupcake/Pupcake/wiki/_pages\r\n\r\n##Installation:\r\n\r\n###If you plan to use it on Apache\r\n#### install package \"Pupcake/Pupcake\" using composer (http://getcomposer.org/)\r\n####.htaccess File for Apache\r\n    RewriteEngine On\r\n    RewriteCond %{REQUEST_FILENAME} !-f\r\n    RewriteRule ^(.*)$ index.php/$1 [L]\r\n\r\n###If you plan to use it as a standalone async server\r\n#### install package \"Pupcake/Pupcake\" using composer (http://getcomposer.org/)\r\n#### install php-uv and php-httpparser\r\n    git clone https://github.com/chobie/php-uv.git --recursive\r\n    cd php-uv/libuv\r\n    make && cp uv.a libuv.a (my experience on both centos and ubuntu server is, we need to add -fPIC flag to cc)\r\n    cd ..\r\n    phpize\r\n    ./configure\r\n    make && make install (my experience on both centos and ubuntu server is, we need to add -fPIC flag to cc)\r\n\r\n    git clone https://github.com/chobie/php-httpparser.git --recursive\r\n    cd php-httpparser\r\n    phpize\r\n    ./configure\r\n    make && make install\r\n\r\n    add following extensions to your php.ini\r\n    extension=uv.so\r\n    extension=httpparser.so\r\n\r\n\r\n###Simple requests when running on Apache\r\n```php\r\n<?php\r\n//Assuming this is public/index.php and the composer vendor directory is ../vendor\r\n\r\nrequire_once __DIR__.'/../vendor/autoload.php';\r\n\r\n$app = new Pupcake\\Pupcake();\r\n\r\n$app->get(\"date/:year/:month/:day\", function($req, $res){\r\n    $output = $req->params('year').'-'.$req->params('month').'-'.$req->params('day');\r\n    $res->send($output);\r\n});\r\n\r\n$app->get(\"/hello/:name\", function($req, $res){\r\n  $res->send(\"hello \".$req->params('name').\" in get\");\r\n});\r\n\r\n$app->post(\"/hello/:name\", function($req, $res){\r\n  $res->send(\"hello \".$req->params('name').\" in post\");\r\n});\r\n\r\n$app->put(\"/hello/:name\", function($req, $res){\r\n  $res->send(\"hello \".$req->params('name').\" in put\");\r\n});\r\n\r\n$app->delete(\"/hello/:name\", function($req, $res){\r\n  $res->send(\"hello \".$req->params('name').\" in delete\");\r\n});\r\n\r\n/**\r\n * Multiple request methods for one route\r\n */\r\n$app->map(\"/api/hello/:action\", function($req, $res){\r\n  $res->send(\"hello \".$req->params('action').\" in get and post\");\r\n})->via('GET','POST');\r\n\r\n\r\n$app->run();\r\n```\r\n\r\n### A simple standalone server to listen to port 9000 in local\r\nWrite a php script named server.php in the server folder\r\n```php\r\n<?php\r\n//Assuming this is server/server.php and the composer vendor directory is ../vendor\r\nrequire_once __DIR__.'/../vendor/autoload.php';\r\n\r\n$app = new Pupcake\\Pupcake();\r\n\r\n$app->usePlugin(\"Pupcake\\Plugin\\AsyncServer\");\r\n\r\n$app->listen(\"127.0.0.1\", 9000);\r\n\r\n$app->get(\"/\", function($req, $res){\r\n  $res->sendJSON(array('ok' => true));\r\n});\r\n\r\n$app->get(\"/hello\", function($req, $res){\r\n  $res->sendJSON(array('word' => 'hello'));\r\n});\r\n\r\n$app->run();\r\n```\r\nNow run php server/server.php and go to http://127.0.0.1:9000 to see the result\r\n\r\n### A simple standalone server returning \"Hello Word\", benchmarked with node.js\r\nWe can return any custom output by skipping the whole routing process by hooking up to system.server.response.body event\r\n```php\r\n<?php\r\nrequire_once __DIR__.'/../vendor/autoload.php';\r\n\r\n$app = new Pupcake\\Pupcake();\r\n\r\n$app->usePlugin(\"Pupcake\\Plugin\\AsyncServer\");\r\n\r\n$app->listen(\"127.0.0.1\", 9000);\r\n\r\n$app->on(\"system.server.response.body\", function($event){\r\n  return \"hello world\\n\";\r\n});\r\n\r\n$app->run();\r\n```\r\n\r\nThis might need more investigation, but the script above seems to be able to handle more requests per seconds than Node.js\r\n\r\nBenchmarking compared with the following node.js script\r\n```javascript\r\nvar http = require('http');\r\nhttp.createServer(function (req, res) {\r\n    res.writeHead(200, {'Content-Type': 'text/plain'});\r\n    res.end('Hello World\\n');\r\n    }).listen(1337, '127.0.0.1');\r\nconsole.log('Server running at http://127.0.0.1:1337/');\r\n```\r\nBelow are the data return by apache ab:\r\nab -n 100000 -c 200 http://127.0.0.1:9000/ (our php server)\r\n\r\n    Concurrency Level:      200\r\n    Time taken for tests:   22.338 seconds\r\n    Complete requests:      100000\r\n    Failed requests:        0\r\n    Write errors:           0\r\n    Total transferred:      3100000 bytes\r\n    HTML transferred:       1200000 bytes\r\n    Requests per second:    4476.65 [#/sec] (mean)\r\n    Time per request:       44.676 [ms] (mean)\r\n    Time per request:       0.223 [ms] (mean, across all concurrent requests)\r\n    Transfer rate:          135.52 [Kbytes/sec] received\r\n\r\nab -n 100000 -c 200 http://127.0.0.1:1337/ (the node.js hello world script run with node version 0.8.5)\r\n\r\n    Concurrency Level:      200\r\n    Time taken for tests:   25.660 seconds\r\n    Complete requests:      100000\r\n    Failed requests:        0\r\n    Write errors:           0\r\n    Total transferred:      11300000 bytes\r\n    HTML transferred:       1200000 bytes\r\n    Requests per second:    3897.19 [#/sec] (mean)\r\n    Time per request:       51.319 [ms] (mean)\r\n    Time per request:       0.257 [ms] (mean, across all concurrent requests)\r\n    Transfer rate:          430.06 [Kbytes/sec] received\r\n","name":"Pupcake","google":""}