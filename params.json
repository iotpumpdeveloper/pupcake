{"body":"Pupcake --- a micro framework for PHP 5.3+\r\n=======================================\r\n\r\n##About Pupcake Framework\r\n+ Pupcake is a minimal but extensible microframework for PHP 5.3+\r\n+ Pupcake can be run in traditional web server such as Apache and can also run as a standalone async server using the AsyncServer plugin together with php-uv and php-httpparser\r\n  (The standalone async server is at its very early stage and is under active development)\r\n+ For more detail usages on using pupcake in general and on traditional web servers, please see https://github.com/superjimpupcake/Pupcake/wiki/_pages\r\n+ To see what pupcake can do as a standalone async server, see this readme page, a lot of the async server features are experimental now but it will demonstrate what Pupcake can do.\r\n\r\n##Installation:\r\n\r\n###If you plan to use it on Apache\r\n#### install package \"Pupcake/Pupcake\" using composer (http://getcomposer.org/)\r\n####.htaccess File for Apache\r\n    RewriteEngine On\r\n    RewriteCond %{REQUEST_FILENAME} !-f\r\n    RewriteRule ^(.*)$ index.php/$1 [L]\r\n\r\n###If you plan to use it as a standalone async server\r\n#### install package \"Pupcake/Pupcake\" using composer (http://getcomposer.org/)\r\n#### install php-uv and php-httpparser\r\n    git clone https://github.com/chobie/php-uv.git --recursive\r\n    cd php-uv/libuv\r\n    make && cp uv.a libuv.a (my experience on both centos and ubuntu server is, we need to add -fPIC flag to cc)\r\n    cd ..\r\n    phpize\r\n    ./configure\r\n    make && make install (my experience on both centos and ubuntu server is, we need to add -fPIC flag to cc)\r\n\r\n    git clone https://github.com/chobie/php-httpparser.git --recursive\r\n    cd php-httpparser\r\n    phpize\r\n    ./configure\r\n    make && make install\r\n\r\n    add following extensions to your php.ini\r\n    extension=uv.so\r\n    extension=httpparser.so\r\n\r\n\r\n###Simple requests when running on Apache\r\n```php\r\n<?php\r\n//Assuming this is public/index.php and the composer vendor directory is ../vendor\r\n\r\nrequire_once __DIR__.'/../vendor/autoload.php';\r\n\r\n$app = new Pupcake\\Pupcake();\r\n\r\n$app->get(\"date/:year/:month/:day\", function($req, $res){\r\n    $output = $req->params('year').'-'.$req->params('month').'-'.$req->params('day');\r\n    $res->send($output);\r\n});\r\n\r\n$app->get(\"/hello/:name\", function($req, $res){\r\n  $res->send(\"hello \".$req->params('name').\" in get\");\r\n});\r\n\r\n$app->post(\"/hello/:name\", function($req, $res){\r\n  $res->send(\"hello \".$req->params('name').\" in post\");\r\n});\r\n\r\n$app->put(\"/hello/:name\", function($req, $res){\r\n  $res->send(\"hello \".$req->params('name').\" in put\");\r\n});\r\n\r\n$app->delete(\"/hello/:name\", function($req, $res){\r\n  $res->send(\"hello \".$req->params('name').\" in delete\");\r\n});\r\n\r\n/**\r\n * Multiple request methods for one route\r\n */\r\n$app->map(\"/api/hello/:action\", function($req, $res){\r\n  $res->send(\"hello \".$req->params('action').\" in get and post\");\r\n})->via('GET','POST');\r\n\r\n\r\n$app->run();\r\n```\r\n\r\n### A simple standalone server to listen to port 9000 in local\r\nWrite a php script named server.php in the server folder\r\n```php\r\n<?php\r\n//Assuming this is server/server.php and the composer vendor directory is ../vendor\r\nrequire_once __DIR__.'/../vendor/autoload.php';\r\n\r\n$app = new Pupcake\\Pupcake();\r\n\r\n$app->usePlugin(\"Pupcake\\Plugin\\AsyncServer\");\r\n\r\n$app->listen(\"127.0.0.1\", 9000);\r\n\r\n$app->get(\"/\", function($req, $res){\r\n  $res->sendJSON(array('ok' => true));\r\n});\r\n\r\n$app->get(\"/hello\", function($req, $res){\r\n  $res->sendJSON(array('word' => 'hello'));\r\n});\r\n\r\n$app->run();\r\n```\r\nNow run php server/server.php and go to http://127.0.0.1:9000 to see the result\r\n\r\n### A simple standalone server returning \"Hello Word\", benchmarked with node.js\r\nWe can return any custom output by skipping the whole routing process by hooking up to system.server.response.body event\r\n```php\r\n<?php\r\nrequire_once __DIR__.'/../vendor/autoload.php';\r\n\r\n$app = new Pupcake\\Pupcake();\r\n\r\n$app->usePlugin(\"Pupcake\\Plugin\\AsyncServer\");\r\n\r\n$app->listen(\"127.0.0.1\", 9000);\r\n\r\n$app->on(\"system.server.response.body\", function($event){\r\n  return \"hello world\\n\";\r\n});\r\n\r\n$app->run();\r\n```\r\n\r\nThis might need more investigation, but the script above seems to be able to handle more requests per seconds than Node.js\r\n\r\nBenchmarking compared with the following node.js script\r\n```javascript\r\nvar http = require('http');\r\nhttp.createServer(function (req, res) {\r\n    res.writeHead(200, {'Content-Type': 'text/plain'});\r\n    res.end('Hello World\\n');\r\n    }).listen(1337, '127.0.0.1');\r\nconsole.log('Server running at http://127.0.0.1:1337/');\r\n```\r\nBelow are the data return by apache ab:\r\nab -n 100000 -c 200 http://127.0.0.1:9000/ (our php server)\r\n\r\n    Concurrency Level:      200\r\n    Time taken for tests:   22.338 seconds\r\n    Complete requests:      100000\r\n    Failed requests:        0\r\n    Write errors:           0\r\n    Total transferred:      3100000 bytes\r\n    HTML transferred:       1200000 bytes\r\n    Requests per second:    4476.65 [#/sec] (mean)\r\n    Time per request:       44.676 [ms] (mean)\r\n    Time per request:       0.223 [ms] (mean, across all concurrent requests)\r\n    Transfer rate:          135.52 [Kbytes/sec] received\r\n\r\nab -n 100000 -c 200 http://127.0.0.1:1337/ (the node.js hello world script run with node version 0.8.5)\r\n\r\n    Concurrency Level:      200\r\n    Time taken for tests:   25.660 seconds\r\n    Complete requests:      100000\r\n    Failed requests:        0\r\n    Write errors:           0\r\n    Total transferred:      11300000 bytes\r\n    HTML transferred:       1200000 bytes\r\n    Requests per second:    3897.19 [#/sec] (mean)\r\n    Time per request:       51.319 [ms] (mean)\r\n    Time per request:       0.257 [ms] (mean, across all concurrent requests)\r\n    Transfer rate:          430.06 [Kbytes/sec] received\r\n\r\n### (Experimental and Demo only) Process forking in an async fashion\r\nIn the example below, we will create 2 processes, test1 and test2, test1 will sleep for 10 seconds and return a string \"test 1\", test2\r\nwill return a string \"test 2\" immediately, what we want is, run test1 and test2 as 2 separate process and return their outputs together \r\non each request, and we do not want to block all the incoming requests. The process test1 and test2 are called process closures, since it \r\ntake a closure function as the main code body and run as a separate process.\r\n```php\r\n<?php\r\n//Assuming this is server/server.php and the composer vendor directory is ../vendor\r\nrequire_once __DIR__.'/../vendor/autoload.php';\r\n\r\n$app = new Pupcake\\Pupcake();\r\n$app->usePlugin(\"Pupcake\\Plugin\\AsyncServer\");\r\n\r\n$app->listen(\"127.0.0.1\", 9000);\r\n\r\n$pm = $app->getProcessClosureManager();\r\n$pm->setMaxNumberOfProcess(10);\r\n$pm->setProcessDirectory(__DIR__.\"/processes\"); //tell the system where to store all the process related files\r\n$pm->addProcess(\"test1\", function(){\r\n  sleep(10);\r\n  return \"test 1\";\r\n});\r\n\r\n$pm->addProcess(\"test2\", function(){\r\n  return \"hello test2\";\r\n});\r\n\r\n$app->on(\"system.server.response.body\", function($event) use ($app, $pm){\r\n  $test1_output = $pm->getProcessOutput(\"test1\");\r\n  $test2_output = $pm->getProcessOutput(\"test2\");\r\n  return $test1_output.\",\".$test2_output;\r\n});\r\n\r\n$app->run();\r\n```\r\nNow run php server/server.php and go to 127.0.0.1:9000, we should see \",hello test2\", since process test1 does not return yet, it is still sleeping. \r\nAfter 10 seconds, go to 127.0.0.1:9000, we should see \"test 1,hello test2\" since now process test1 return \"test1\". \r\n","tagline":"Pupcake, a PHP 5.3+ application framework","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"Pupcake"}